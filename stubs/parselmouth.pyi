"""
Main module with a Python interface to Praat.

.. data:: VERSION
    :annotation: = '0.5.0.dev0'

    This version of Parselmouth.

.. data:: PRAAT_VERSION
    :annotation: = '6.4.16'

    The Praat version on which this version of Parselmouth is based.

.. data:: PRAAT_VERSION_DATE
    :annotation: = '29 July 2024'

    The release date of the Praat version on which this version of
    Parselmouth is based.

"""
from __future__ import annotations
import numpy
import typing
from typing import Annotated
from annotated_types import Ge

__all__ = ['AmplitudeScaling', 'CC', 'Data', 'Formant', 'FormantUnit', 'Function', 'Harmonicity', 'Intensity', 'Interpolation', 'MFCC', 'Matrix', 'PRAAT_VERSION', 'PRAAT_VERSION_DATE', 'Pitch', 'PitchUnit', 'PraatError', 'PraatFatal', 'PraatWarning', 'Sampled', 'SampledXY', 'SignalOutsideTimeDomain', 'Sound', 'SoundFileFormat', 'SpectralAnalysisWindowShape', 'Spectrogram', 'Spectrum', 'TextGrid', 'Thing', 'TimeFrameSampled', 'TimeFunction', 'VERSION', 'ValueInterpolation', 'Vector', 'WindowShape', 'praat', 'read']
class AmplitudeScaling:
    INTEGRAL: typing.ClassVar[AmplitudeScaling]  # value = <AmplitudeScaling.INTEGRAL: 1>
    NORMALIZE: typing.ClassVar[AmplitudeScaling]  # value = <AmplitudeScaling.NORMALIZE: 3>
    PEAK_0_99: typing.ClassVar[AmplitudeScaling]  # value = <AmplitudeScaling.PEAK_0_99: 4>
    SUM: typing.ClassVar[AmplitudeScaling]  # value = <AmplitudeScaling.SUM: 2>
    __members__: typing.ClassVar[dict[str, AmplitudeScaling]]  # value = {'INTEGRAL': <AmplitudeScaling.INTEGRAL: 1>, 'SUM': <AmplitudeScaling.SUM: 2>, 'NORMALIZE': <AmplitudeScaling.NORMALIZE: 3>, 'PEAK_0_99': <AmplitudeScaling.PEAK_0_99: 4>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> ...:
        """
        __init__(self: parselmouth.AmplitudeScaling, arg0: str) -> None
        """
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class CC(TimeFrameSampled, Sampled):
    class Frame:
        c0: float
        def __getitem__(self, i: int) -> float:
            ...
        def __len__(self) -> int:
            ...
        def __setitem__(self, i: int, value: float) -> None:
            ...
        def to_array(self) -> numpy.ndarray[numpy.float64]:
            ...
        @property
        def c(self) -> numpy.ndarray:
            ...
    def __getitem__(self, i: int) -> ...:
        """
        __getitem__(self: parselmouth.CC, ij: Tuple[int, int]) -> float
        """
    def __iter__(self) -> typing.Iterator:
        ...
    def __setitem__(self, ij: tuple[int, int], value: float) -> None:
        ...
    def get_c0_value_in_frame(self, frame_number: Annotated[int, Ge(0)]) -> float:
        ...
    def get_frame(self, frame_number: Annotated[int, Ge(0)]) -> CC.Frame:
        ...
    def get_number_of_coefficients(self, frame_number: Annotated[int, Ge(0)]) -> int:
        ...
    def get_value_in_frame(self, frame_number: Annotated[int, Ge(0)], index: Annotated[int, Ge(0)]) -> float:
        ...
    def to_array(self) -> numpy.ndarray[numpy.float64]:
        ...
    def to_matrix(self) -> Matrix:
        ...
    @property
    def fmax(self) -> float:
        ...
    @property
    def fmin(self) -> float:
        ...
    @property
    def max_n_coefficients(self) -> int:
        ...
class Data(Thing):
    class FileFormat:
        BINARY: typing.ClassVar[Data.FileFormat]  # value = <FileFormat.BINARY: 2>
        SHORT_TEXT: typing.ClassVar[Data.FileFormat]  # value = <FileFormat.SHORT_TEXT: 1>
        TEXT: typing.ClassVar[Data.FileFormat]  # value = <FileFormat.TEXT: 0>
        __members__: typing.ClassVar[dict[str, Data.FileFormat]]  # value = {'TEXT': <FileFormat.TEXT: 0>, 'SHORT_TEXT': <FileFormat.SHORT_TEXT: 1>, 'BINARY': <FileFormat.BINARY: 2>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> ...:
            """
            __init__(self: parselmouth.Data.FileFormat, arg0: str) -> None
            """
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def read(file_path: str) -> Data:
        """
        Read a file into a `parselmouth.Data` object.
        
        Parameters
        ----------
        file_path : str
            The path of the file on disk to read.
        
        Returns
        -------
        parselmouth.Data
            The Praat Data object that was read.
        
        See also
        --------
        :praat:`Read from file...`
        """
    def __copy__(self) -> Data:
        ...
    def __deepcopy__(self, memo: dict) -> Data:
        ...
    def __eq__(self, other: Data) -> bool:
        ...
    def __ne__(self, other: Data) -> bool:
        ...
    def copy(self) -> Data:
        ...
    def save(self, file_path: str, format: Data.FileFormat = ...) -> None:
        ...
    def save_as_binary_file(self, file_path: str) -> None:
        ...
    def save_as_short_text_file(self, file_path: str) -> None:
        ...
    def save_as_text_file(self, file_path: str) -> None:
        ...
class Formant(TimeFrameSampled, Sampled):
    def get_bandwidth_at_time(self, formant_number: Annotated[int, Ge(0)], time: float, unit: FormantUnit = ...) -> float:
        ...
    def get_value_at_time(self, formant_number: Annotated[int, Ge(0)], time: float, unit: FormantUnit = ...) -> float:
        ...
class FormantUnit:
    BARK: typing.ClassVar[FormantUnit]  # value = <FormantUnit.BARK: 1>
    HERTZ: typing.ClassVar[FormantUnit]  # value = <FormantUnit.HERTZ: 0>
    __members__: typing.ClassVar[dict[str, FormantUnit]]  # value = {'HERTZ': <FormantUnit.HERTZ: 0>, 'BARK': <FormantUnit.BARK: 1>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> ...:
        """
        __init__(self: parselmouth.FormantUnit, arg0: str) -> None
        """
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class Function(Data):
    xmax: float
    xmin: float
    xrange: tuple[float, float]
    def scale_x_by(self, scale: Annotated[float, Ge(0.0)]) -> None:
        ...
    def scale_x_to(self, new_xmin: float, new_xmax: float) -> None:
        ...
    def shift_x_by(self, shift: float) -> None:
        ...
    def shift_x_to(self, x: float, new_x: float) -> None:
        ...
class Harmonicity(TimeFrameSampled, Vector):
    def get_value(self, time: float, interpolation: ValueInterpolation = ...) -> float:
        ...
class Intensity(TimeFrameSampled, Vector):
    class AveragingMethod:
        DB: typing.ClassVar[Intensity.AveragingMethod]  # value = <AveragingMethod.DB: 3>
        ENERGY: typing.ClassVar[Intensity.AveragingMethod]  # value = <AveragingMethod.ENERGY: 1>
        MEDIAN: typing.ClassVar[Intensity.AveragingMethod]  # value = <AveragingMethod.MEDIAN: 0>
        SONES: typing.ClassVar[Intensity.AveragingMethod]  # value = <AveragingMethod.SONES: 2>
        __members__: typing.ClassVar[dict[str, Intensity.AveragingMethod]]  # value = {'MEDIAN': <AveragingMethod.MEDIAN: 0>, 'ENERGY': <AveragingMethod.ENERGY: 1>, 'SONES': <AveragingMethod.SONES: 2>, 'DB': <AveragingMethod.DB: 3>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> ...:
            """
            __init__(self: parselmouth.Intensity.AveragingMethod, arg0: str) -> None
            """
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    def get_average(self, from_time: float | None = None, to_time: float | None = None, averaging_method: Intensity.AveragingMethod = ...) -> float:
        ...
    def get_value(self, time: float, interpolation: ValueInterpolation = ...) -> float:
        ...
class MFCC(CC):
    def convolve(self, other: MFCC, scaling: AmplitudeScaling = ..., signal_outside_time_domain: SignalOutsideTimeDomain = ...) -> Sound:
        ...
    def cross_correlate(self, other: MFCC, scaling: AmplitudeScaling = ..., signal_outside_time_domain: SignalOutsideTimeDomain = ...) -> Sound:
        ...
    def extract_features(self, window_length: Annotated[float, Ge(0.0)] = 0.025, include_energy: bool = False) -> Matrix:
        ...
    def to_matrix_features(self, window_length: Annotated[float, Ge(0.0)] = 0.025, include_energy: bool = False) -> Matrix:
        ...
    def to_sound(self) -> Sound:
        ...
class Matrix(SampledXY):
    values: numpy.ndarray[numpy.float64]
    def __buffer__(self, flags):
        """
        Return a buffer object that exposes the underlying memory of the object.
        """
    def __release_buffer__(self, buffer):
        """
        Release the buffer object that exposes the underlying memory of the object.
        """
    def as_array(self) -> numpy.ndarray[numpy.float64]:
        ...
    def at_xy(self, x: float, y: float) -> float:
        ...
    def formula(self, formula: str, from_x: float | None = None, to_x: float | None = None, from_y: float | None = None, to_y: float | None = None) -> ...:
        """
        formula(self: parselmouth.Matrix, formula: str, x_range: Tuple[Optional[float], Optional[float]] = (None, None), y_range: Tuple[Optional[float], Optional[float]] = (None, None)) -> None
        """
    def get_column_distance(self) -> float:
        ...
    def get_highest_x(self) -> float:
        ...
    def get_highest_y(self) -> float:
        ...
    def get_lowest_x(self) -> float:
        ...
    def get_lowest_y(self) -> float:
        ...
    def get_maximum(self) -> float:
        ...
    def get_minimum(self) -> float:
        ...
    def get_number_of_columns(self) -> int:
        ...
    def get_number_of_rows(self) -> int:
        ...
    def get_row_distance(self) -> float:
        ...
    def get_sum(self) -> float:
        ...
    def get_value_at_xy(self, x: float, y: float) -> float:
        ...
    def get_value_in_cell(self, row_number: Annotated[int, Ge(0)], column_number: Annotated[int, Ge(0)]) -> float:
        ...
    def get_x_of_column(self, column_number: Annotated[int, Ge(0)]) -> float:
        ...
    def get_y_of_row(self, row_number: Annotated[int, Ge(0)]) -> float:
        ...
    def save_as_headerless_spreadsheet_file(self, file_path: str) -> None:
        ...
    def save_as_matrix_text_file(self, file_path: str) -> None:
        ...
    def set_value(self, row_number: Annotated[int, Ge(0)], column_number: Annotated[int, Ge(0)], new_value: float) -> None:
        ...
    @property
    def n_columns(self) -> int:
        ...
    @property
    def n_rows(self) -> int:
        ...
class Pitch(TimeFrameSampled, Sampled):
    class Candidate:
        @property
        def frequency(self) -> float:
            ...
        @property
        def strength(self) -> float:
            ...
    class Frame:
        selected: Pitch.Candidate
        def __getitem__(self, i: int) -> Pitch.Candidate:
            ...
        def __len__(self) -> int:
            ...
        def as_array(self) -> numpy.ndarray:
            ...
        def select(self, candidate: Pitch.Candidate) -> ...:
            """
            select(self: parselmouth.Pitch.Frame, i: int) -> None
            """
        def unvoice(self) -> None:
            ...
        @property
        def candidates(self) -> list[Pitch.Candidate]:
            ...
        @property
        def intensity(self) -> float:
            ...
    ceiling: float
    def __getitem__(self, i: int) -> ...:
        """
        __getitem__(self: parselmouth.Pitch, ij: Tuple[int, int]) -> parselmouth.Pitch.Candidate
        """
    def __iter__(self) -> typing.Iterator:
        ...
    def count_differences(self, other: Pitch) -> str:
        ...
    def count_voiced_frames(self) -> int:
        ...
    def fifth_down(self, from_time: float | None = None, to_time: float | None = None) -> None:
        ...
    def fifth_up(self, from_time: float | None = None, to_time: float | None = None) -> None:
        ...
    def formula(self, formula: str) -> None:
        ...
    def get_frame(self, frame_number: Annotated[int, Ge(0)]) -> Pitch.Frame:
        ...
    def get_mean_absolute_slope(self, unit: PitchUnit = ...) -> float:
        ...
    def get_slope_without_octave_jumps(self) -> float:
        ...
    def get_value_at_time(self, time: float, unit: PitchUnit = ..., interpolation: ValueInterpolation = ...) -> float:
        ...
    def get_value_in_frame(self, frame_number: int, unit: PitchUnit = ...) -> float:
        ...
    def interpolate(self) -> Pitch:
        ...
    def kill_octave_jumps(self) -> Pitch:
        ...
    def octave_down(self, from_time: float | None = None, to_time: float | None = None) -> None:
        ...
    def octave_up(self, from_time: float | None = None, to_time: float | None = None) -> None:
        ...
    def path_finder(self, silence_threshold: float = 0.03, voicing_threshold: float = 0.45, octave_cost: float = 0.01, octave_jump_cost: float = 0.35, voiced_unvoiced_cost: float = 0.14, ceiling: Annotated[float, Ge(0.0)] = 600.0, pull_formants: bool = False) -> None:
        ...
    def smooth(self, bandwidth: Annotated[float, Ge(0.0)] = 10.0) -> Pitch:
        ...
    def step(self, step: float, precision: Annotated[float, Ge(0.0)] = 0.1, from_time: float | None = None, to_time: float | None = None) -> None:
        ...
    def subtract_linear_fit(self, unit: PitchUnit = ...) -> Pitch:
        ...
    def to_array(self) -> numpy.ndarray[Pitch.Candidate]:
        ...
    def to_matrix(self) -> Matrix:
        ...
    def to_sound_hum(self, from_time: float | None = None, to_time: float | None = None) -> Sound:
        ...
    def to_sound_pulses(self, from_time: float | None = None, to_time: float | None = None) -> Sound:
        ...
    def to_sound_sine(self, from_time: float | None = None, to_time: float | None = None, sampling_frequency: Annotated[float, Ge(0.0)] = 44100.0, round_to_nearest_zero_crossing: float = True) -> Sound:
        ...
    def unvoice(self, from_time: float | None = None, to_time: float | None = None) -> None:
        ...
    @property
    def max_n_candidates(self) -> int:
        ...
    @property
    def selected(self) -> list[Pitch.Candidate]:
        ...
    @property
    def selected_array(self) -> numpy.ndarray[Pitch.Candidate]:
        ...
class PitchUnit:
    ERB: typing.ClassVar[PitchUnit]  # value = <PitchUnit.ERB: 8>
    HERTZ: typing.ClassVar[PitchUnit]  # value = <PitchUnit.HERTZ: 0>
    HERTZ_LOGARITHMIC: typing.ClassVar[PitchUnit]  # value = <PitchUnit.HERTZ_LOGARITHMIC: 1>
    LOG_HERTZ: typing.ClassVar[PitchUnit]  # value = <PitchUnit.LOG_HERTZ: 3>
    MEL: typing.ClassVar[PitchUnit]  # value = <PitchUnit.MEL: 2>
    SEMITONES_1: typing.ClassVar[PitchUnit]  # value = <PitchUnit.SEMITONES_1: 4>
    SEMITONES_100: typing.ClassVar[PitchUnit]  # value = <PitchUnit.SEMITONES_100: 5>
    SEMITONES_200: typing.ClassVar[PitchUnit]  # value = <PitchUnit.SEMITONES_200: 6>
    SEMITONES_440: typing.ClassVar[PitchUnit]  # value = <PitchUnit.SEMITONES_440: 7>
    __members__: typing.ClassVar[dict[str, PitchUnit]]  # value = {'HERTZ': <PitchUnit.HERTZ: 0>, 'HERTZ_LOGARITHMIC': <PitchUnit.HERTZ_LOGARITHMIC: 1>, 'MEL': <PitchUnit.MEL: 2>, 'LOG_HERTZ': <PitchUnit.LOG_HERTZ: 3>, 'SEMITONES_1': <PitchUnit.SEMITONES_1: 4>, 'SEMITONES_100': <PitchUnit.SEMITONES_100: 5>, 'SEMITONES_200': <PitchUnit.SEMITONES_200: 6>, 'SEMITONES_440': <PitchUnit.SEMITONES_440: 7>, 'ERB': <PitchUnit.ERB: 8>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> ...:
        """
        __init__(self: parselmouth.PitchUnit, arg0: str) -> None
        """
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class PraatError(RuntimeError):
    pass
class PraatFatal(BaseException):
    pass
class PraatWarning(UserWarning):
    pass
class Sampled(Function):
    def __len__(self) -> int:
        ...
    def x_bins(self) -> numpy.ndarray[numpy.float64]:
        ...
    def x_grid(self) -> numpy.ndarray[numpy.float64]:
        ...
    def xs(self) -> numpy.ndarray[numpy.float64]:
        ...
    @property
    def dx(self) -> float:
        ...
    @property
    def nx(self) -> int:
        ...
    @property
    def x1(self) -> float:
        ...
class SampledXY(Sampled):
    def y_bins(self) -> numpy.ndarray[numpy.float64]:
        ...
    def y_grid(self) -> numpy.ndarray[numpy.float64]:
        ...
    def ys(self) -> numpy.ndarray[numpy.float64]:
        ...
    @property
    def dy(self) -> float:
        ...
    @property
    def ny(self) -> int:
        ...
    @property
    def y1(self) -> float:
        ...
    @property
    def ymax(self) -> float:
        ...
    @property
    def ymin(self) -> float:
        ...
    @property
    def yrange(self) -> tuple[float, float]:
        ...
class SignalOutsideTimeDomain:
    SIMILAR: typing.ClassVar[SignalOutsideTimeDomain]  # value = <SignalOutsideTimeDomain.SIMILAR: 2>
    ZERO: typing.ClassVar[SignalOutsideTimeDomain]  # value = <SignalOutsideTimeDomain.ZERO: 1>
    __members__: typing.ClassVar[dict[str, SignalOutsideTimeDomain]]  # value = {'ZERO': <SignalOutsideTimeDomain.ZERO: 1>, 'SIMILAR': <SignalOutsideTimeDomain.SIMILAR: 2>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> ...:
        """
        __init__(self: parselmouth.SignalOutsideTimeDomain, arg0: str) -> None
        """
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class Sound(TimeFrameSampled, Vector):
    """
    A fragment of audio, represented by one or multiple channels of floating
    point values between -1 and 1, sampled at a fixed sampling frequency.
    
    Corresponds to a :praat:`Sound` object.
    
    See Also
    --------
    :praat:`Sound`, :praat:`Sound files`,
    :praat:`Sound files 1. General structure`
    """
    class ToHarmonicityMethod:
        AC: typing.ClassVar[Sound.ToHarmonicityMethod]  # value = <ToHarmonicityMethod.AC: 1>
        CC: typing.ClassVar[Sound.ToHarmonicityMethod]  # value = <ToHarmonicityMethod.CC: 0>
        GNE: typing.ClassVar[Sound.ToHarmonicityMethod]  # value = <ToHarmonicityMethod.GNE: 2>
        __members__: typing.ClassVar[dict[str, Sound.ToHarmonicityMethod]]  # value = {'AC': <ToHarmonicityMethod.AC: 1>, 'CC': <ToHarmonicityMethod.CC: 0>, 'GNE': <ToHarmonicityMethod.GNE: 2>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> ...:
            """
            __init__(self: parselmouth.Sound.ToHarmonicityMethod, arg0: str) -> None
            """
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    class ToPitchMethod:
        AC: typing.ClassVar[Sound.ToPitchMethod]  # value = <ToPitchMethod.AC: 0>
        CC: typing.ClassVar[Sound.ToPitchMethod]  # value = <ToPitchMethod.CC: 1>
        SHS: typing.ClassVar[Sound.ToPitchMethod]  # value = <ToPitchMethod.SHS: 3>
        SPINET: typing.ClassVar[Sound.ToPitchMethod]  # value = <ToPitchMethod.SPINET: 2>
        __members__: typing.ClassVar[dict[str, Sound.ToPitchMethod]]  # value = {'AC': <ToPitchMethod.AC: 0>, 'CC': <ToPitchMethod.CC: 1>, 'SPINET': <ToPitchMethod.SPINET: 2>, 'SHS': <ToPitchMethod.SHS: 3>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> ...:
            """
            __init__(self: parselmouth.Sound.ToPitchMethod, arg0: str) -> None
            """
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    sampling_frequency: float
    sampling_period: float
    @staticmethod
    def combine_to_stereo(sounds: list[Sound]) -> Sound:
        ...
    @staticmethod
    def concatenate(sounds: list[Sound], overlap: Annotated[float, Ge(0.0)] = 0.0) -> Sound:
        ...
    def __init__(self, other: Sound) -> ...:
        """
        __init__(self: parselmouth.Sound, values: numpy.ndarray[numpy.float64], sampling_frequency: Annotated[float, Ge(0.0)] = 44100.0, start_time: float = 0.0) -> None \\
        __init__(self: parselmouth.Sound, file_path: str) -> None
        
        Create a new `Sound` object.
        
        The new object can be created:
        - as a copy of an existing `Sound` object,
        - from an array of samples and a sampling frequency, or
        - by reading an audio file from disk.
        
        Parameters
        ----------
        other : Sound
            The `Sound` object to copy.
        samples : array_like[float]
            The samples of the new `Sound` object.
        sampling_frequency : float, optional
            The sampling frequency of the new `Sound` object (default: 44100).
        start_time : float, optional
            The start time (`~Function.xmin`) of the new `Sound` object
            (default: 0).
        file_name : str, optional
            The file name of the audio file to load.
        file_path : str
            The file path of an audio file to load from disk.
        
        See Also
        --------
        :praat:`Sound files 2. File types`,
        :praat:`Sound files 3. Files that Praat can read`
        """
    def autocorrelate(self, scaling: AmplitudeScaling = ..., signal_outside_time_domain: SignalOutsideTimeDomain = ...) -> Sound:
        ...
    def convert_to_mono(self) -> Sound:
        ...
    def convert_to_stereo(self) -> Sound:
        ...
    def convolve(self, other: Sound, scaling: AmplitudeScaling = ..., signal_outside_time_domain: SignalOutsideTimeDomain = ...) -> Sound:
        ...
    def cross_correlate(self, other: Sound, scaling: AmplitudeScaling = ..., signal_outside_time_domain: SignalOutsideTimeDomain = ...) -> Sound:
        ...
    def de_emphasize(self, from_frequency: float = 50.0, normalize: bool = True) -> None:
        ...
    def deepen_band_modulation(self, enhancement: Annotated[float, Ge(0.0)] = 20.0, from_frequency: Annotated[float, Ge(0.0)] = 300.0, to_frequency: Annotated[float, Ge(0.0)] = 8000.0, slow_modulation: Annotated[float, Ge(0.0)] = 3.0, fast_modulation: Annotated[float, Ge(0.0)] = 30.0, band_smoothing: Annotated[float, Ge(0.0)] = 100.0) -> Sound:
        ...
    def extract_all_channels(self) -> list[Sound]:
        ...
    def extract_channel(self, channel: int) -> ...:
        """
        extract_channel(self: parselmouth.Sound, arg0: str) -> parselmouth.Sound
        """
    def extract_left_channel(self) -> Sound:
        ...
    def extract_part(self, from_time: float | None = None, to_time: float | None = None, window_shape: WindowShape = ..., relative_width: Annotated[float, Ge(0.0)] = 1.0, preserve_times: bool = False) -> Sound:
        ...
    def extract_part_for_overlap(self, from_time: float | None = None, to_time: float | None = None, overlap: Annotated[float, Ge(0.0)] = 0.0) -> Sound:
        ...
    def extract_right_channel(self) -> Sound:
        ...
    def get_energy(self, from_time: float | None = None, to_time: float | None = None) -> float:
        ...
    def get_energy_in_air(self) -> float:
        ...
    def get_index_from_time(self, time: float) -> float:
        ...
    def get_intensity(self) -> float:
        ...
    def get_nearest_zero_crossing(self, time: float, channel: int = 1) -> float:
        ...
    def get_number_of_channels(self) -> int:
        ...
    def get_number_of_samples(self) -> int:
        ...
    def get_power(self, from_time: float | None = None, to_time: float | None = None) -> float:
        ...
    def get_power_in_air(self) -> float:
        ...
    def get_rms(self, from_time: float | None = None, to_time: float | None = None) -> float:
        ...
    def get_root_mean_square(self, from_time: float | None = None, to_time: float | None = None) -> float:
        ...
    def get_sampling_frequency(self) -> float:
        ...
    def get_sampling_period(self) -> float:
        ...
    def get_time_from_index(self, sample: int) -> float:
        ...
    def lengthen(self, minimum_pitch: Annotated[float, Ge(0.0)] = 75.0, maximum_pitch: Annotated[float, Ge(0.0)] = 600.0, factor: Annotated[float, Ge(0.0)] = 0.0) -> Sound:
        ...
    def multiply_by_window(self, window_shape: WindowShape) -> None:
        ...
    def override_sampling_frequency(self, new_frequency: Annotated[float, Ge(0.0)]) -> None:
        ...
    def pre_emphasize(self, from_frequency: float = 50.0, normalize: bool = True) -> None:
        ...
    def resample(self, new_frequency: float, precision: int = 50) -> Sound:
        ...
    def reverse(self, from_time: float | None = None, to_time: float | None = None) -> None:
        ...
    def save(self, file_path: str, format: SoundFileFormat) -> None:
        """
        Save a `Sound` object to an audio file on disk.
        
        Parameters
        ----------
        file_path : str
            The file path of the audio file to save to disk.
        file_format : `SoundFileFormat`
            The audio file format to write to. This can either be a
            `SoundFileFormat` value (e.g., `SoundFileFormat.WAV`), or the string
            representation of the value (e.g., ``"WAV"``).
        
        See Also
        --------
        :praat:`Sound files 2. File types`,
        :praat:`Sound files 4. Files that Praat can write`
        """
    def scale_intensity(self, new_average_intensity: float) -> None:
        ...
    def set_to_zero(self, from_time: float | None = None, to_time: float | None = None, round_to_nearest_zero_crossing: bool = True) -> None:
        ...
    def to_formant_burg(self, time_step: Annotated[float, Ge(0.0)] | None = None, max_number_of_formants: Annotated[float, Ge(0.0)] = 5.0, maximum_formant: float = 5500.0, window_length: Annotated[float, Ge(0.0)] = 0.025, pre_emphasis_from: Annotated[float, Ge(0.0)] = 50.0) -> Formant:
        ...
    def to_harmonicity(self, method: Sound.ToHarmonicityMethod = ..., *args, **kwargs) -> typing.Any:
        ...
    def to_harmonicity_ac(self, time_step: Annotated[float, Ge(0.0)] = 0.01, minimum_pitch: Annotated[float, Ge(0.0)] = 75.0, silence_threshold: float = 0.1, periods_per_window: Annotated[float, Ge(0.0)] = 1.0) -> Harmonicity:
        ...
    def to_harmonicity_cc(self, time_step: Annotated[float, Ge(0.0)] = 0.01, minimum_pitch: Annotated[float, Ge(0.0)] = 75.0, silence_threshold: float = 0.1, periods_per_window: Annotated[float, Ge(0.0)] = 1.0) -> Harmonicity:
        ...
    def to_harmonicity_gne(self, minimum_frequency: Annotated[float, Ge(0.0)] = 500.0, maximum_frequency: Annotated[float, Ge(0.0)] = 4500.0, bandwidth: Annotated[float, Ge(0.0)] = 1000.0, step: Annotated[float, Ge(0.0)] = 80.0) -> Matrix:
        ...
    def to_intensity(self, minimum_pitch: Annotated[float, Ge(0.0)] = 100.0, time_step: Annotated[float, Ge(0.0)] | None = None, subtract_mean: bool = True) -> Intensity:
        ...
    def to_mfcc(self, number_of_coefficients: Annotated[int, Ge(0)] = 12, window_length: Annotated[float, Ge(0.0)] = 0.015, time_step: Annotated[float, Ge(0.0)] = 0.005, firstFilterFreqency: Annotated[float, Ge(0.0)] = 100.0, distance_between_filters: Annotated[float, Ge(0.0)] = 100.0, maximum_frequency: Annotated[float, Ge(0.0)] | None = None) -> MFCC:
        ...
    def to_pitch(self, time_step: Annotated[float, Ge(0.0)] | None = None, pitch_floor: Annotated[float, Ge(0.0)] = 75.0, pitch_ceiling: Annotated[float, Ge(0.0)] = 600.0) -> ...:
        """
        to_pitch(self: parselmouth.Sound, method: parselmouth.Sound.ToPitchMethod, *args, **kwargs) -> object
        """
    def to_pitch_ac(self, time_step: Annotated[float, Ge(0.0)] | None = None, pitch_floor: Annotated[float, Ge(0.0)] = 75.0, max_number_of_candidates: Annotated[int, Ge(0)] = 15, very_accurate: bool = False, silence_threshold: float = 0.03, voicing_threshold: float = 0.45, octave_cost: float = 0.01, octave_jump_cost: float = 0.35, voiced_unvoiced_cost: float = 0.14, pitch_ceiling: Annotated[float, Ge(0.0)] = 600.0) -> Pitch:
        ...
    def to_pitch_cc(self, time_step: Annotated[float, Ge(0.0)] | None = None, pitch_floor: Annotated[float, Ge(0.0)] = 75.0, max_number_of_candidates: Annotated[int, Ge(0)] = 15, very_accurate: bool = False, silence_threshold: float = 0.03, voicing_threshold: float = 0.45, octave_cost: float = 0.01, octave_jump_cost: float = 0.35, voiced_unvoiced_cost: float = 0.14, pitch_ceiling: Annotated[float, Ge(0.0)] = 600.0) -> Pitch:
        ...
    def to_pitch_shs(self, time_step: Annotated[float, Ge(0.0)] = 0.01, minimum_pitch: Annotated[float, Ge(0.0)] = 50.0, max_number_of_candidates: Annotated[int, Ge(0)] = 15, maximum_frequency_component: Annotated[float, Ge(0.0)] = 1250.0, max_number_of_subharmonics: Annotated[int, Ge(0)] = 15, compression_factor: Annotated[float, Ge(0.0)] = 0.84, ceiling: Annotated[float, Ge(0.0)] = 600.0, number_of_points_per_octave: Annotated[int, Ge(0)] = 48) -> Pitch:
        ...
    def to_pitch_spinet(self, time_step: Annotated[float, Ge(0.0)] = 0.005, window_length: Annotated[float, Ge(0.0)] = 0.04, minimum_filter_frequency: Annotated[float, Ge(0.0)] = 70.0, maximum_filter_frequency: Annotated[float, Ge(0.0)] = 5000.0, number_of_filters: Annotated[int, Ge(0)] = 250, ceiling: Annotated[float, Ge(0.0)] = 500.0, max_number_of_candidates: Annotated[int, Ge(0)] = 15) -> Pitch:
        ...
    def to_spectrogram(self, window_length: Annotated[float, Ge(0.0)] = 0.005, maximum_frequency: Annotated[float, Ge(0.0)] = 5000.0, time_step: Annotated[float, Ge(0.0)] = 0.002, frequency_step: Annotated[float, Ge(0.0)] = 20.0, window_shape: SpectralAnalysisWindowShape = ...) -> Spectrogram:
        ...
    def to_spectrum(self, fast: bool = True) -> Spectrum:
        ...
    @property
    def n_channels(self) -> int:
        ...
    @property
    def n_samples(self) -> int:
        ...
class SoundFileFormat:
    AIFC: typing.ClassVar[SoundFileFormat]  # value = <SoundFileFormat.AIFC: 2>
    AIFF: typing.ClassVar[SoundFileFormat]  # value = <SoundFileFormat.AIFF: 1>
    FLAC: typing.ClassVar[SoundFileFormat]  # value = <SoundFileFormat.FLAC: 5>
    KAY: typing.ClassVar[SoundFileFormat]  # value = <SoundFileFormat.KAY: 6>
    NEXT_SUN: typing.ClassVar[SoundFileFormat]  # value = <SoundFileFormat.NEXT_SUN: 3>
    NIST: typing.ClassVar[SoundFileFormat]  # value = <SoundFileFormat.NIST: 4>
    RAW_16_BE: typing.ClassVar[SoundFileFormat]  # value = <SoundFileFormat.RAW_16_BE: 12>
    RAW_16_LE: typing.ClassVar[SoundFileFormat]  # value = <SoundFileFormat.RAW_16_LE: 13>
    RAW_24_BE: typing.ClassVar[SoundFileFormat]  # value = <SoundFileFormat.RAW_24_BE: 14>
    RAW_24_LE: typing.ClassVar[SoundFileFormat]  # value = <SoundFileFormat.RAW_24_LE: 15>
    RAW_32_BE: typing.ClassVar[SoundFileFormat]  # value = <SoundFileFormat.RAW_32_BE: 16>
    RAW_32_LE: typing.ClassVar[SoundFileFormat]  # value = <SoundFileFormat.RAW_32_LE: 17>
    RAW_8_SIGNED: typing.ClassVar[SoundFileFormat]  # value = <SoundFileFormat.RAW_8_SIGNED: 10>
    RAW_8_UNSIGNED: typing.ClassVar[SoundFileFormat]  # value = <SoundFileFormat.RAW_8_UNSIGNED: 11>
    SESAM: typing.ClassVar[SoundFileFormat]  # value = <SoundFileFormat.SESAM: 7>
    WAV: typing.ClassVar[SoundFileFormat]  # value = <SoundFileFormat.WAV: 0>
    WAV_24: typing.ClassVar[SoundFileFormat]  # value = <SoundFileFormat.WAV_24: 8>
    WAV_32: typing.ClassVar[SoundFileFormat]  # value = <SoundFileFormat.WAV_32: 9>
    __members__: typing.ClassVar[dict[str, SoundFileFormat]]  # value = {'WAV': <SoundFileFormat.WAV: 0>, 'AIFF': <SoundFileFormat.AIFF: 1>, 'AIFC': <SoundFileFormat.AIFC: 2>, 'NEXT_SUN': <SoundFileFormat.NEXT_SUN: 3>, 'NIST': <SoundFileFormat.NIST: 4>, 'FLAC': <SoundFileFormat.FLAC: 5>, 'KAY': <SoundFileFormat.KAY: 6>, 'SESAM': <SoundFileFormat.SESAM: 7>, 'WAV_24': <SoundFileFormat.WAV_24: 8>, 'WAV_32': <SoundFileFormat.WAV_32: 9>, 'RAW_8_SIGNED': <SoundFileFormat.RAW_8_SIGNED: 10>, 'RAW_8_UNSIGNED': <SoundFileFormat.RAW_8_UNSIGNED: 11>, 'RAW_16_BE': <SoundFileFormat.RAW_16_BE: 12>, 'RAW_16_LE': <SoundFileFormat.RAW_16_LE: 13>, 'RAW_24_BE': <SoundFileFormat.RAW_24_BE: 14>, 'RAW_24_LE': <SoundFileFormat.RAW_24_LE: 15>, 'RAW_32_BE': <SoundFileFormat.RAW_32_BE: 16>, 'RAW_32_LE': <SoundFileFormat.RAW_32_LE: 17>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> ...:
        """
        __init__(self: parselmouth.SoundFileFormat, arg0: str) -> None
        """
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class SpectralAnalysisWindowShape:
    BARTLETT: typing.ClassVar[SpectralAnalysisWindowShape]  # value = <SpectralAnalysisWindowShape.BARTLETT: 2>
    GAUSSIAN: typing.ClassVar[SpectralAnalysisWindowShape]  # value = <SpectralAnalysisWindowShape.GAUSSIAN: 5>
    HAMMING: typing.ClassVar[SpectralAnalysisWindowShape]  # value = <SpectralAnalysisWindowShape.HAMMING: 1>
    HANNING: typing.ClassVar[SpectralAnalysisWindowShape]  # value = <SpectralAnalysisWindowShape.HANNING: 4>
    SQUARE: typing.ClassVar[SpectralAnalysisWindowShape]  # value = <SpectralAnalysisWindowShape.SQUARE: 0>
    WELCH: typing.ClassVar[SpectralAnalysisWindowShape]  # value = <SpectralAnalysisWindowShape.WELCH: 3>
    __members__: typing.ClassVar[dict[str, SpectralAnalysisWindowShape]]  # value = {'SQUARE': <SpectralAnalysisWindowShape.SQUARE: 0>, 'HAMMING': <SpectralAnalysisWindowShape.HAMMING: 1>, 'BARTLETT': <SpectralAnalysisWindowShape.BARTLETT: 2>, 'WELCH': <SpectralAnalysisWindowShape.WELCH: 3>, 'HANNING': <SpectralAnalysisWindowShape.HANNING: 4>, 'GAUSSIAN': <SpectralAnalysisWindowShape.GAUSSIAN: 5>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> ...:
        """
        __init__(self: parselmouth.SpectralAnalysisWindowShape, arg0: str) -> None
        """
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class Spectrogram(TimeFrameSampled, Matrix):
    def get_power_at(self, time: float, frequency: float) -> float:
        ...
    def synthesize_sound(self, sampling_frequency: Annotated[float, Ge(0.0)] = 44100.0) -> Sound:
        ...
    def to_sound(self, sampling_frequency: Annotated[float, Ge(0.0)] = 44100.0) -> Sound:
        ...
    def to_spectrum_slice(self, time: float) -> Spectrum:
        ...
class Spectrum(Matrix):
    def __getitem__(self, index: int) -> complex:
        ...
    def __init__(self, values: numpy.ndarray[numpy.float64], maximum_frequency: Annotated[float, Ge(0.0)]) -> ...:
        """
        __init__(self: parselmouth.Spectrum, values: numpy.ndarray[numpy.complex128], maximum_frequency: Annotated[float, Ge(0.0)]) -> None
        """
    def __setitem__(self, index: int, value: complex) -> None:
        ...
    def cepstral_smoothing(self, bandwidth: Annotated[float, Ge(0.0)] = 500.0) -> Spectrum:
        ...
    def get_band_density(self, band_floor: float | None = None, band_ceiling: float | None = None) -> ...:
        """
        get_band_density(self: parselmouth.Spectrum, band: Tuple[Optional[float], Optional[float]] = (None, None)) -> float
        """
    def get_band_density_difference(self, low_band_floor: float | None = None, low_band_ceiling: float | None = None, high_band_floor: float | None = None, high_band_ceiling: float | None = None) -> ...:
        """
        get_band_density_difference(self: parselmouth.Spectrum, low_band: Tuple[Optional[float], Optional[float]] = (None, None), high_band: Tuple[Optional[float], Optional[float]] = (None, None)) -> float
        """
    def get_band_energy(self, band_floor: float | None = None, band_ceiling: float | None = None) -> ...:
        """
        get_band_energy(self: parselmouth.Spectrum, band: Tuple[Optional[float], Optional[float]] = (None, None)) -> float
        """
    def get_band_energy_difference(self, low_band_floor: float | None = None, low_band_ceiling: float | None = None, high_band_floor: float | None = None, high_band_ceiling: float | None = None) -> ...:
        """
        get_band_energy_difference(self: parselmouth.Spectrum, low_band: Tuple[Optional[float], Optional[float]] = (None, None), high_band: Tuple[Optional[float], Optional[float]] = (None, None)) -> float
        """
    def get_bin_number_from_frequency(self, frequency: float) -> float:
        ...
    def get_bin_width(self) -> float:
        ...
    def get_center_of_gravity(self, power: Annotated[float, Ge(0.0)] = 2.0) -> float:
        ...
    def get_central_moment(self, moment: Annotated[float, Ge(0.0)], power: Annotated[float, Ge(0.0)] = 2.0) -> float:
        ...
    def get_centre_of_gravity(self, power: Annotated[float, Ge(0.0)] = 2.0) -> float:
        ...
    def get_frequency_from_bin_number(self, band_number: Annotated[int, Ge(0)]) -> float:
        ...
    def get_highest_frequency(self) -> float:
        ...
    def get_imaginary_value_in_bin(self, bin_number: Annotated[int, Ge(0)]) -> float:
        ...
    def get_kurtosis(self, power: Annotated[float, Ge(0.0)] = 2.0) -> float:
        ...
    def get_lowest_frequency(self) -> float:
        ...
    def get_number_of_bins(self) -> int:
        ...
    def get_real_value_in_bin(self, bin_number: Annotated[int, Ge(0)]) -> float:
        ...
    def get_skewness(self, power: Annotated[float, Ge(0.0)] = 2.0) -> float:
        ...
    def get_standard_deviation(self, power: Annotated[float, Ge(0.0)] = 2.0) -> float:
        ...
    def get_value_in_bin(self, bin_number: Annotated[int, Ge(0)]) -> complex:
        ...
    def lpc_smoothing(self, num_peaks: Annotated[int, Ge(0)] = 5, pre_emphasis_from: Annotated[float, Ge(0.0)] = 50.0) -> Spectrum:
        ...
    def set_imaginary_value_in_bin(self, bin_number: Annotated[int, Ge(0)], value: float) -> None:
        ...
    def set_real_value_in_bin(self, bin_number: Annotated[int, Ge(0)], value: float) -> None:
        ...
    def set_value_in_bin(self, bin_number: Annotated[int, Ge(0)], value: complex) -> None:
        ...
    def to_sound(self) -> Sound:
        ...
    def to_spectrogram(self) -> Spectrogram:
        ...
    @property
    def bin_width(self) -> float:
        ...
    @property
    def df(self) -> float:
        ...
    @property
    def fmax(self) -> float:
        ...
    @property
    def fmin(self) -> float:
        ...
    @property
    def highest_frequency(self) -> float:
        ...
    @property
    def lowest_frequency(self) -> float:
        ...
    @property
    def n_bins(self) -> int:
        ...
    @property
    def nf(self) -> int:
        ...
class TextGrid(Function):
    @staticmethod
    def from_tgt(tgt_text_grid: tgt.core.TextGrid) -> TextGrid:
        ...
    def __init__(self, start_time: float, end_time: float, tier_names: str, point_tier_names: str) -> ...:
        """
        __init__(self: parselmouth.TextGrid, start_time: float, end_time: float, tier_names: List[str] = [], point_tier_names: List[str] = []) -> None \\
        __init__(self: parselmouth.TextGrid, tgt_text_grid: tgt.core.TextGrid) -> None
        """
    def to_tgt(self, *, include_empty_intervals: bool = False) -> tgt.core.TextGrid:
        ...
class Thing:
    name: str
    def __str__(self) -> str:
        ...
    def info(self) -> str:
        ...
    @property
    def class_name(self) -> str:
        ...
    @property
    def full_name(self) -> str:
        ...
class TimeFrameSampled(TimeFunction, Sampled):
    def frame_number_to_time(self: Sampled, frame_number: Annotated[int, Ge(0)]) -> float:
        ...
    def get_frame_number_from_time(self: Sampled, time: float) -> float:
        ...
    def get_number_of_frames(self: Sampled) -> int:
        ...
    def get_time_from_frame_number(self: Sampled, frame_number: Annotated[int, Ge(0)]) -> float:
        ...
    def get_time_step(self: Sampled) -> float:
        ...
    def t_bins(self: Sampled) -> numpy.ndarray[numpy.float64]:
        ...
    def t_grid(self: Sampled) -> numpy.ndarray[numpy.float64]:
        ...
    def time_to_frame_number(self: Sampled, time: float) -> float:
        ...
    def ts(self: Sampled) -> numpy.ndarray[numpy.float64]:
        ...
    @property
    def dt(self) -> float:
        ...
    @property
    def n_frames(self) -> int:
        ...
    @property
    def nt(self) -> int:
        ...
    @property
    def t1(self) -> float:
        ...
    @property
    def time_step(self) -> float:
        ...
class TimeFunction(Function):
    centre_time: float
    end_time: float
    start_time: float
    time_range: tuple[float, float]
    tmax: float
    tmin: float
    trange: tuple[float, float]
    def get_end_time(self: Function) -> float:
        ...
    def get_start_time(self: Function) -> float:
        ...
    def get_total_duration(self: Function) -> float:
        ...
    def scale_times_by(self: Function, scale: Annotated[float, Ge(0.0)]) -> None:
        ...
    def scale_times_to(self: Function, new_start_time: float, new_end_time: float) -> None:
        ...
    def shift_times_by(self: Function, seconds: float) -> None:
        ...
    def shift_times_to(self: Function, time: float, new_time: float) -> ...:
        """
        shift_times_to(self: parselmouth.Function, time: str, new_time: float) -> None
        """
    @property
    def duration(self) -> float:
        ...
    @property
    def total_duration(self) -> float:
        ...
class ValueInterpolation:
    CUBIC: typing.ClassVar[ValueInterpolation]  # value = <ValueInterpolation.CUBIC: 2>
    LINEAR: typing.ClassVar[ValueInterpolation]  # value = <ValueInterpolation.LINEAR: 1>
    NEAREST: typing.ClassVar[ValueInterpolation]  # value = <ValueInterpolation.NEAREST: 0>
    SINC70: typing.ClassVar[ValueInterpolation]  # value = <ValueInterpolation.SINC70: 3>
    SINC700: typing.ClassVar[ValueInterpolation]  # value = <ValueInterpolation.SINC700: 4>
    __members__: typing.ClassVar[dict[str, ValueInterpolation]]  # value = {'NEAREST': <ValueInterpolation.NEAREST: 0>, 'LINEAR': <ValueInterpolation.LINEAR: 1>, 'CUBIC': <ValueInterpolation.CUBIC: 2>, 'SINC70': <ValueInterpolation.SINC70: 3>, 'SINC700': <ValueInterpolation.SINC700: 4>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> ...:
        """
        __init__(self: parselmouth.ValueInterpolation, arg0: str) -> None
        """
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class Vector(Matrix):
    def __add__(self, number: float) -> Vector:
        ...
    def __iadd__(self, number: float) -> Vector:
        ...
    def __imul__(self, factor: float) -> Vector:
        ...
    def __isub__(self, number: float) -> Vector:
        ...
    def __itruediv__(self, factor: float) -> Vector:
        ...
    def __mul__(self, factor: float) -> Vector:
        ...
    def __radd__(self, number: float) -> Vector:
        ...
    def __rmul__(self, factor: float) -> Vector:
        ...
    def __sub__(self, number: float) -> Vector:
        ...
    def __truediv__(self, factor: float) -> Vector:
        ...
    def add(self, number: float) -> None:
        ...
    def divide(self, factor: float) -> None:
        ...
    def get_value(self, x: float, channel: int | None = None, interpolation: ValueInterpolation = ...) -> float:
        ...
    def multiply(self, factor: float) -> None:
        ...
    def scale(self, scale: Annotated[float, Ge(0.0)]) -> None:
        ...
    def scale_peak(self, new_peak: Annotated[float, Ge(0.0)] = 0.99) -> None:
        ...
    def subtract(self, number: float) -> None:
        ...
    def subtract_mean(self) -> None:
        ...
class WindowShape:
    GAUSSIAN1: typing.ClassVar[WindowShape]  # value = <WindowShape.GAUSSIAN1: 5>
    GAUSSIAN2: typing.ClassVar[WindowShape]  # value = <WindowShape.GAUSSIAN2: 6>
    GAUSSIAN3: typing.ClassVar[WindowShape]  # value = <WindowShape.GAUSSIAN3: 7>
    GAUSSIAN4: typing.ClassVar[WindowShape]  # value = <WindowShape.GAUSSIAN4: 8>
    GAUSSIAN5: typing.ClassVar[WindowShape]  # value = <WindowShape.GAUSSIAN5: 9>
    HAMMING: typing.ClassVar[WindowShape]  # value = <WindowShape.HAMMING: 4>
    HANNING: typing.ClassVar[WindowShape]  # value = <WindowShape.HANNING: 3>
    KAISER1: typing.ClassVar[WindowShape]  # value = <WindowShape.KAISER1: 10>
    KAISER2: typing.ClassVar[WindowShape]  # value = <WindowShape.KAISER2: 11>
    PARABOLIC: typing.ClassVar[WindowShape]  # value = <WindowShape.PARABOLIC: 2>
    RECTANGULAR: typing.ClassVar[WindowShape]  # value = <WindowShape.RECTANGULAR: 0>
    TRIANGULAR: typing.ClassVar[WindowShape]  # value = <WindowShape.TRIANGULAR: 1>
    __members__: typing.ClassVar[dict[str, WindowShape]]  # value = {'RECTANGULAR': <WindowShape.RECTANGULAR: 0>, 'TRIANGULAR': <WindowShape.TRIANGULAR: 1>, 'PARABOLIC': <WindowShape.PARABOLIC: 2>, 'HANNING': <WindowShape.HANNING: 3>, 'HAMMING': <WindowShape.HAMMING: 4>, 'GAUSSIAN1': <WindowShape.GAUSSIAN1: 5>, 'GAUSSIAN2': <WindowShape.GAUSSIAN2: 6>, 'GAUSSIAN3': <WindowShape.GAUSSIAN3: 7>, 'GAUSSIAN4': <WindowShape.GAUSSIAN4: 8>, 'GAUSSIAN5': <WindowShape.GAUSSIAN5: 9>, 'KAISER1': <WindowShape.KAISER1: 10>, 'KAISER2': <WindowShape.KAISER2: 11>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> ...:
        """
        __init__(self: parselmouth.WindowShape, arg0: str) -> None
        """
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
def read(file_path: str) -> Data:
    """
    Read a file into a `parselmouth.Data` object.
    
    Parameters
    ----------
    file_path : str
        The path of the file on disk to read.
    
    Returns
    -------
    parselmouth.Data
        The Praat Data object that was read.
    
    See also
    --------
    :praat:`Read from file...`
    """
PRAAT_VERSION: str = '6.4.16'
PRAAT_VERSION_DATE: str = '29 July 2024'
VERSION: str = '0.5.0.dev0'
__version__: str = '0.5.0.dev0'
Interpolation = ValueInterpolation
